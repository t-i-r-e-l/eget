# Инструкция по установке и настройке eGET

## Содержание

1. [Установка](#установка)
2. [Настройка сервера](#настройка-сервера)
3. [Настройка клиента](#настройка-клиента)
4. [Проверка работы](#проверка-работы)
5. [Решение проблем](#решение-проблем)

## Установка

### Вариант 1: Сборка из исходников

```bash
# Клонируйте репозиторий
git clone https://github.com/t-i-r-e-l/eget.git
cd eget

# Установите зависимости
go mod download

# Соберите сервер
go build -o eget-server server.go

# Соберите клиент
go build -o eget-client client.go
```

### Вариант 2: Установка через go install

```bash
go install github.com/t-i-r-e-l/eget/server@latest
go install github.com/t-i-r-e-l/eget/client@latest
```

Бинарные файлы будут в `$GOPATH/bin` или `$HOME/go/bin`.

## Настройка сервера

### Шаг 1: Создание конфигурационного файла

Скопируйте пример конфигурации:

```bash
cp config.example.json users.json
```

### Шаг 2: Генерация ключей для пользователей

Каждый пользователь должен иметь уникальный 32-символьный hex-ключ (16 байт):

```bash
# Генерация случайного ключа
openssl rand -hex 16
```

Пример вывода: `d9a4c1ed5b69875abcf15e1ef8ae8f37`

### Шаг 3: Редактирование users.json

Откройте `users.json` и добавьте пользователей:

```json
{
  "users": {
    "admin": "d9a4c1ed5b69875abcf15e1ef8ae8f37",
    "user1": "62130bd9c1538eef230ae41d100e91d2",
    "user2": "4e5f7a8b9c0d1e2f3a4b5c6d7e8f9a0b"
  },
  "static_path": "static/index.html",
  "routing": {
    "rules": []
  }
}
```

**Важно**: 
- Ключи должны быть ровно 32 символа (hex)
- Не используйте примеры ключей из `config.example.json` в продакшене
- Храните `users.json` в безопасном месте

### Шаг 4: Настройка маршрутизации (опционально)

Если нужно маршрутизировать трафик через другие прокси:

**Использование отдельных правил:**

```json
{
  "routing": {
    "rules": [
      {
        "type": "exact",
        "pattern": "example.com",
        "upstream": "socks5://127.0.0.1:1081"
      },
      {
        "type": "suffix",
        "pattern": ".google.com",
        "upstream": "socks5://127.0.0.1:1082"
      }
    ]
  }
}
```

**Использование файла со списком доменов:**

1. Создайте файл со списком доменов (например, `domains.txt`):
   ```bash
   cp domains.example.txt domains.txt
   ```

2. Отредактируйте `domains.txt`, добавив нужные домены:
   ```
   # Точные совпадения
   example.com
   blocked-site.com
   
   # Суффиксы (все поддомены)
   .google.com
   .facebook.com
   ```

3. Добавьте правило в `users.json`:
   ```json
   {
     "routing": {
       "rules": [
         {
           "type": "list",
           "list_file": "domains.txt",
           "upstream": "socks5://127.0.0.1:1081"
         }
       ]
     }
   }
   ```

**Формат файла списка доменов:**
- Каждая строка = один домен
- Строки, начинающиеся с `#`, являются комментариями
- Пустые строки игнорируются
- Домены, начинающиеся с точки (например, `.google.com`), считаются суффиксами
- Поддерживаются IDN домены (кириллица)
- Комментарии в конце строки также поддерживаются

См. пример в файле `domains.example.txt`

### Шаг 5: Запуск сервера

```bash
./eget-server -listen :8080 -config users.json
```

Или с дополнительными параметрами:

```bash
./eget-server \
  -listen :8080 \
  -config users.json \
  -poll-timeout 8 \
  -chunk-size 8192 \
  -verbose
```

### Шаг 6: Проверка работы сервера

Откройте в браузере: `http://your-server:8080/`

Должна отобразиться страница или ответ от сервера.

## Настройка клиента

### Шаг 1: Получение ключа

Получите ваш ключ от администратора сервера или используйте ключ, который вы добавили в `users.json`.

### Шаг 2: Запуск клиента

**Базовый запуск:**

```bash
./eget-client \
  -server http://your-server.com/tunnel \
  -key d9a4c1ed5b69875abcf15e1ef8ae8f37
```

**С использованием переменной окружения (рекомендуется):**

```bash
export EGET_KEY=d9a4c1ed5b69875abcf15e1ef8ae8f37
./eget-client -server http://your-server.com/tunnel
```

**С оптимизацией производительности:**

```bash
./eget-client \
  -server http://your-server.com/tunnel \
  -key $EGET_KEY \
  -put -chunked \
  -chunk-size 8192 \
  -timeout 20 \
  -pollers 16
```

### Шаг 3: Проверка работы клиента

После запуска клиент создаст локальный SOCKS5 прокси на `127.0.0.1:1080` (по умолчанию).

Проверьте логи:
```bash
tail -f client.log
```

Должны появиться сообщения о подключении к серверу.

## Проверка работы

### Тест 1: Проверка SOCKS5 прокси

Используйте curl для проверки:

```bash
curl --socks5 127.0.0.1:1080 http://ifconfig.me
```

Или настройте браузер на использование SOCKS5 прокси `127.0.0.1:1080`.

### Тест 2: Проверка через браузер

1. Настройте браузер на использование SOCKS5 прокси `127.0.0.1:1080`
2. Откройте любой сайт
3. Проверьте логи клиента и сервера

### Тест 3: Проверка производительности

```bash
# Установите verbose режим
./eget-client -server http://your-server.com/tunnel -key $EGET_KEY -verbose

# Откройте сайт в браузере и наблюдайте за логами
```

## Решение проблем

### Проблема: Клиент не может подключиться к серверу

**Решение:**
1. Проверьте доступность сервера: `curl http://your-server.com/tunnel?id=test&user=test`
2. Проверьте правильность URL (должен заканчиваться на `/tunnel`)
3. Проверьте файрвол и сетевые настройки
4. Убедитесь, что сервер запущен

### Проблема: Ошибка аутентификации

**Решение:**
1. Проверьте правильность ключа (должен быть 32 hex символа)
2. Убедитесь, что ключ совпадает с ключом в `users.json` на сервере
3. Проверьте, что пользователь существует в конфигурации сервера

### Проблема: Медленная работа

**Решение:**
1. Используйте `-put -chunked` для лучшей производительности
2. Увеличьте `-chunk-size` до 16384 или 32768 (если сеть позволяет)
3. Увеличьте количество поллеров: `-pollers 32`
4. Настройте таймауты в зависимости от задержек сети

### Проблема: Ошибки шифрования

**Решение:**
1. Убедитесь, что ключ правильный (32 hex символа)
2. Проверьте, что ключ не был изменен между клиентом и сервером
3. Перезапустите клиент и сервер

### Проблема: Таймауты при работе

**Решение:**
1. Увеличьте `-timeout` на клиенте до 30-60 секунд
2. Увеличьте `-read-timeout` на сервере до 300 секунд
3. Используйте `-put -chunked` режим для лучшей производительности
4. Проверьте сетевое соединение и задержки

### Проблема: Сессия не восстанавливается после перезапуска

**Решение:**
Это нормальное поведение. Сессии хранятся в памяти и очищаются при перезапуске. Клиент автоматически создаст новую сессию при следующем запросе.

## Дополнительные настройки

### Запуск как системный сервис (systemd)

Создайте файл `/etc/systemd/system/eget-server.service`:

```ini
[Unit]
Description=eGET Server
After=network.target

[Service]
Type=simple
User=your-user
WorkingDirectory=/path/to/eget
ExecStart=/path/to/eget/eget-server -listen :8080 -config /path/to/eget/users.json
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

Запустите:
```bash
sudo systemctl enable eget-server
sudo systemctl start eget-server
```

### Примеры использования

**Базовое использование:**
```bash
# 1. Запустите сервер на удаленной машине
./eget-server -listen :8080 -config users.json

# 2. На локальной машине запустите клиент
./eget-client -server http://your-server.com:8080/tunnel -key YOUR_KEY

# 3. Настройте браузер на SOCKS5 прокси 127.0.0.1:1080
# Или используйте curl:
curl --socks5 127.0.0.1:1080 http://example.com
```

**Использование с переменной окружения:**
```bash
# Установите ключ в переменную окружения
export EGET_KEY=d9a4c1ed5b69875abcf15e1ef8ae8f37

# Запустите клиент (ключ будет взят из переменной)
./eget-client -server http://your-server.com:8080/tunnel
```

**Использование с разными портами:**
```bash
# Запустите клиент на порту 9050 (например, для Tor Browser)
./eget-client -server http://your-server.com:8080/tunnel \
  -key $EGET_KEY \
  -listen 127.0.0.1:9050
```

**Оптимизированная конфигурация:**
```bash
# Клиент с оптимизацией производительности
./eget-client -server http://your-server.com:8080/tunnel \
  -key $EGET_KEY \
  -put -chunked \
  -chunk-size 8192 \
  -pollers 16 \
  -timeout 20
```

## Безопасность

1. **Никогда не коммитьте `users.json` в git** - используйте `.gitignore`
2. **Используйте HTTPS** для сервера в продакшене
3. **Регулярно меняйте ключи** пользователей
4. **Ограничьте доступ** к серверу через файрвол
5. **Мониторьте логи** на предмет подозрительной активности

## Поддержка

Если у вас возникли проблемы:

1. Проверьте логи (`server.log` и `client.log`)
2. Запустите с флагом `-verbose` для подробной информации
3. Создайте issue на GitHub с описанием проблемы и логами




